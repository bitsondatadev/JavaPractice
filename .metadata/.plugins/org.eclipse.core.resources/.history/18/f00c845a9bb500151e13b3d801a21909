package DataStructures;

import java.util.List;

/**
 * Binary Tree that is composed of a generic tree node.
 * 
 * Left Node will always be at index 0 by convention.
 * Right Node will always be at index 1 by convention.
 * 
 * Each node can have no more than two children.
 * 
 * @author Brian
 *
 * @param <T>
 */
public class BinaryTreeNode<T extends Object> implements Node<T>{
	private TreeNode<T> node;
	private static final int LEFT_INDEX = 0;
	private static final int RIGHT_INDEX = 0;

	public BinaryTreeNode(T data){
		initNode(null, data, TreeNode.DEFAULT_BRANCHING_FACTOR);
	}
	
	public BinaryTreeNode(T data, int numChildren){
		initNode(null, data, numChildren);
	}
	
	public BinaryTreeNode(TreeNode<T> parent, T data){
		initNode(parent, data, TreeNode.DEFAULT_BRANCHING_FACTOR);
	}
	
	public BinaryTreeNode(TreeNode<T> parent, T data, int numChildren){
		initNode(parent, data, numChildren);
	}
	
	private void initNode(TreeNode<T> parent, T data, int numChildren){
		this.node = new TreeNode<T>(parent, data ,numChildren);
	}

	public List<Node<T>> getChildren() {
		return node.getChildren();
	}
	
	public Node<T> getLeftNode(){
		if(this.node == null || this.node.getChildren().size() == 0 || this.node.getChildren() == null){
			return null;
		}
		return this.node.getChildren().get(LEFT_INDEX);
	}
	
	public void setLeftNode(T data){
		if(this.node == null || this.node.getChildren().size() == 0 || this.node.getChildren() == null){
			return;
		}
		return this.node.getChildren().add(LEFT_INDEX, new BinaryTreeNode(data));
	}

	public Node<T> getRightNode(){
		if(this.node == null || this.node.getChildren().size() < 2 || this.node.getChildren() == null){
			return null;
		}
		return this.node.getChildren().get(RIGHT_INDEX);
	}
	
	public T getData() {
		return node.getData();
	}

	public void setData(T data) {
		this.setData(data);;
	}

}