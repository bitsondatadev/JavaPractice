package Chapter3;

import java.lang.reflect.Array;

public class Question1<T>{

	private Class<T> clazz;
	private T[] arr;
	private int s1, s2, s3, c1, c2, c3, n;
	private final int MIN_ARRAY_SIZE = 6;
	
	/**
	 * To avoid issues with small arrays and indices being too close we make the minimum size of the array 6.
	 * @param clazz
	 * @param n
	 */
	public Question1(Class<T> clazz){
		this.initVariables(clazz, this.MIN_ARRAY_SIZE);
	}
	
	public Question1(Class<T> clazz, int n){
		this.initVariables(clazz, n);
	}
	
	/**
	 * Initialize all indices and creates the initial array.
	 * @param clazz
	 * @param n
	 */
	public void initVariables(Class<T> clazz, int n){
		this.clazz = clazz;
		this.n = n < this.MIN_ARRAY_SIZE ? this.MIN_ARRAY_SIZE : n;

		this.arr = createArray(n);
		this.s1 = 0;
		this.s2 = (int) Math.floor(n * .3333);
		this.s3 = this.s2 * 2;
		this.s3 = this.s3 >= n ? n - 1 : this.s3;
		this.c1 = this.c2 = this.c3 = 0;
	}
	
	/**
	 * Creates array of type T size n.
	 * @param n
	 * @return
	 */
	@SuppressWarnings("unchecked")
	private T[] createArray(int n){
		return (T[])Array.newInstance(this.clazz, n);
	}
	
	/**
	 * An integer is specified to identify the stack and will report if the size of that stack is zero.
	 * If the integer passed doesn't exist then report if all stack sizes are zero.
	 * @param stack
	 * @return
	 */
	public boolean empty(int stack){
		switch(stack){
		case 1: return this.c1 == 0;
		case 2: return this.c2 == 0;
		case 3: return this.c3 == 0;
		}
		return this.empty();
	}
	
	public boolean empty(){
		return this.size() == 0;
	}
	
	public int size(int stack){
		switch(stack){
		case 1: return this.c1;
		case 2: return this.c2;
		case 3: return this.c3;
		}
		return size();
	}
	
	public int size(){
		return this.c1 + this.c2 + this.c3;
	}
	
	public boolean full(){
		return this.size() == this.n;
	}
	
	/**
	 * We default by pointing at the index of next insertion so when peeking or popping we must 
	 * return values one previous to the current stack index.
	 * @param stack
	 * @return
	 */
	public T peek(int stack){
		switch(stack){
		case 1: return this.empty(stack) ? null : this.arr[this.s1 - 1];
		case 2: return this.empty(stack) ? null : this.arr[this.s2 - 1];
		case 3: return this.empty(stack) ? null : this.arr[this.s3 - 1];
		}
		return null;
	}
	
	/**
 	 * We default by pointing at the index of next insertion so when peeking or popping we must 
	 * return values one previous to the current stack index.
	 * @param stack
	 * @return
	 */
	public T pop(int stack){
		switch(stack){
		case 1: if(this.empty(stack)) return null; this.c1--; return this.arr[--this.s1];
		case 2: if(this.empty(stack)) return null; this.c2--; return this.arr[--this.s2];
		case 3: if(this.empty(stack)) return null; this.c3--; return this.arr[--this.s3];
		}
		return null;
	}
	
	public T push(T item, int stack){
		if(item == null){
			return null;
		}else if(this.full() || this.bordering(stack)){
			this.resizeArray();
		}
		
		switch(stack){
		case 1: this.c1++; this.arr[this.s1++] =  item; break;
		case 2: this.c2++; this.arr[this.s2++] =  item; break;
		case 3: this.c3++; this.arr[this.s3++] =  item; break;
		}
		return item;
	}
	
	private void resizeArray(){
		System.out.println("Resize Array!");
	}
	
	private boolean bordering(int stack){
		switch(stack){
		case 1: return this.s1 >= this.bottom(2) && this.s1 <= this.s2 || this.s1 >= this.bottom(3) && this.s1 <= this.s3;
		case 2: return this.s2 >= this.bottom(3) && this.s2 <= this.s3 || this.s2 >= this.bottom(1) && this.s2 <= this.s1;
		case 3: return this.s3 >= this.bottom(1) && this.s3 <= this.s1 || this.s3 >= this.bottom(2) && this.s3 <= this.s2;
		}
		return bordering();
	}
	
	private boolean bordering(){
		return this.s1 >= this.bottom(2) && this.s1 <= this.s2 || this.s1 >= this.bottom(3) && this.s1 <= this.s3 &&
			   this.s2 >= this.bottom(3) && this.s2 <= this.s3 || this.s2 >= this.bottom(1) && this.s2 <= this.s1 &&
			   this.s3 >= this.bottom(1) && this.s3 <= this.s1 || this.s3 >= this.bottom(2) && this.s3 <= this.s2;
	}
	
	private int bottom(int stack){
		int val = -1;
		switch(stack){
		case 1: val = this.s1 - this.c1; return val < 0 ? val + this.n : val;
		case 2: val = this.s2 - this.c2; return val < 0 ? val + this.n : val;
		case 3: val = this.s3 - this.c3; return val < 0 ? val + this.n : val;
		}
		return val;
	}
	
	
}
